// Karno HaritasÄ± Web UygulamasÄ± JavaScript

console.log('ğŸ”§ Karno Script dosyasÄ± yÃ¼klendi!');

// Global uygulama deÄŸiÅŸkeni
let karnoApp;

class KarnoMap {
    constructor() {
        console.log('ğŸš€ KarnoMap constructor baÅŸlatÄ±ldÄ±');
        console.log('ğŸ“ DOM readyState:', document.readyState);
        
        this.variableCount = 4;
        this.variables = ['A', 'B', 'C', 'D'];
        this.truthTable = [];
        this.karnoValues = []; // BaÅŸlangÄ±Ã§ta boÅŸ, generateTruthTable'da dolduracaÄŸÄ±z
        this.groups = [];
        this.currentMethod = 'truthTable';
        this.isLocked = false; // Gruplar bulunduktan sonra kilitleme durumu
        this.hasGroups = false; // Grup varlÄ±ÄŸÄ±nÄ± takip et
        
        // DOM elementlerinin varlÄ±ÄŸÄ±nÄ± kontrol et
        const domCheck = this.checkDOMElements();
        if (!domCheck) {
            console.error('âŒ DOM elementleri eksik, 2 saniye sonra tekrar deneniyor...');
            setTimeout(() => {
                const secondCheck = this.checkDOMElements();
                if (secondCheck) {
                    this.initializeApp();
                } else {
                    console.error('âŒ Ä°kinci denemede de DOM elementleri bulunamadÄ±');
                    console.error('âŒ SayfanÄ±n tam yÃ¼klenmesini bekleyin ve tekrar deneyin');
                }
            }, 2000);
            return;
        }
        
        this.initializeApp();
    }
    
    initializeApp() {
        console.log('ğŸ”§ Uygulama baÅŸlatÄ±lÄ±yor...');
        
        this.initializeEventListeners();
        console.log('âœ… Event listeners baÅŸlatÄ±ldÄ±');
        
        this.generateTruthTable();
        console.log('âœ… Truth table oluÅŸturuldu');
        
        this.generateKarnoMap();
        console.log('âœ… Karno map oluÅŸturuldu');
        
        // DOM render'Ä±nÄ±n tamamlanmasÄ± iÃ§in kÄ±sa bir gecikme
        setTimeout(() => {
            this.verifyRendering();
        }, 100);
        
        // BoÅŸ harita ile baÅŸla - rastgele deÄŸerler oluÅŸturma
        console.log('ğŸ“‹ BoÅŸ Karno haritasÄ± ile baÅŸlanÄ±yor...');
    }

    checkDOMElements() {
        console.log('ğŸ” DOM elementleri kontrol ediliyor...');
        
        const requiredElements = [
            'truthTableContainer',
            'karnoMapContainer',
            'variableCount',
            'truthTableBtn',
            'mintermsBtn'
        ];
        
        const missing = [];
        requiredElements.forEach(id => {
            const element = document.getElementById(id);
            if (!element) {
                missing.push(id);
                console.warn(`âŒ Element bulunamadÄ±: ${id}`);
            } else {
                console.log(`âœ… Element bulundu: ${id}`);
            }
        });
        
        if (missing.length > 0) {
            console.error('âŒ Eksik DOM elementleri:', missing);
            return false;
        } else {
            console.log('âœ… TÃ¼m gerekli DOM elementleri mevcut');
            return true;
        }
    }
    
    verifyRendering() {
        console.log('ğŸ” Render durumu kontrol ediliyor...');
        
        // Truth table kontrolÃ¼
        const truthTableCells = document.querySelectorAll('.truth-table td');
        console.log('ğŸ“Š Truth table hÃ¼creleri:', truthTableCells.length);
        
        // Karno map kontrolÃ¼
        const karnoCells = document.querySelectorAll('.karno-cell');
        console.log('ğŸ—‚ï¸ Karno map hÃ¼creleri:', karnoCells.length);
        
        if (truthTableCells.length === 0) {
            console.error('âŒ Truth table render edilmemiÅŸ!');
        }
        
        if (karnoCells.length === 0) {
            console.error('âŒ Karno map render edilmemiÅŸ!');
        }
        
        if (truthTableCells.length > 0 && karnoCells.length > 0) {
            console.log('âœ… Her ikisi de baÅŸarÄ±yla render edildi!');
        }
    }

    initializeEventListeners() {
        console.log('Event listeners baÅŸlatÄ±lÄ±yor');
        
        // Variable count change
        const variableSelect = document.getElementById('variableCount');
        if (variableSelect) {
            variableSelect.addEventListener('change', (e) => {
                this.variableCount = parseInt(e.target.value);
                this.variables = ['A', 'B', 'C', 'D'].slice(0, this.variableCount);
                this.generateTruthTable();
                this.generateKarnoMap();
                this.clearResults();
                
                // DeÄŸiÅŸken sayÄ±sÄ± deÄŸiÅŸtiÄŸinde boÅŸ harita ile baÅŸla
                console.log('ğŸ”„ DeÄŸiÅŸken sayÄ±sÄ± deÄŸiÅŸti, boÅŸ harita oluÅŸturuluyor...');
            });
        }

        // Input method switching
        const truthTableBtn = document.getElementById('truthTableBtn');
        if (truthTableBtn) {
            truthTableBtn.addEventListener('click', () => {
                this.switchInputMethod('truthTable');
            });
        }

        const mintermsBtn = document.getElementById('mintermsBtn');
        if (mintermsBtn) {
            mintermsBtn.addEventListener('click', () => {
                this.switchInputMethod('minterms');
            });
        }

        // Action buttons
        const clearBtn = document.getElementById('clearBtn');
        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                this.clearAll();
            });
        }

        const randomBtn = document.getElementById('randomBtn');
        if (randomBtn) {
            randomBtn.addEventListener('click', () => {
                this.generateRandom();
            });
        }

        // Minterm input
        const applyMinterms = document.getElementById('applyMinterms');
        if (applyMinterms) {
            applyMinterms.addEventListener('click', () => {
                this.applyMinterms();
            });
        }

        // Map controls
        const findGroupsBtn = document.getElementById('findGroupsBtn');
        if (findGroupsBtn) {
            findGroupsBtn.addEventListener('click', () => {
                this.findGroups();
            });
        }

        const showSolutionBtn = document.getElementById('showSolutionBtn');
        if (showSolutionBtn) {
            showSolutionBtn.addEventListener('click', () => {
                this.showSolution();
            });
        }
    }

    switchInputMethod(method) {
        this.currentMethod = method;
        
        // Update button states
        document.querySelectorAll('.method-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        if (method === 'truthTable') {
            const truthTableBtn = document.getElementById('truthTableBtn');
            const truthTablePanel = document.getElementById('truthTablePanel');
            const mintermsPanel = document.getElementById('mintermsPanel');
            
            if (truthTableBtn) truthTableBtn.classList.add('active');
            if (truthTablePanel) truthTablePanel.classList.add('active');
            if (mintermsPanel) mintermsPanel.classList.remove('active');
        } else {
            const mintermsBtn = document.getElementById('mintermsBtn');
            const mintermsPanel = document.getElementById('mintermsPanel');
            const truthTablePanel = document.getElementById('truthTablePanel');
            
            if (mintermsBtn) mintermsBtn.classList.add('active');
            if (mintermsPanel) mintermsPanel.classList.add('active');
            if (truthTablePanel) truthTablePanel.classList.remove('active');
        }
    }

    generateTruthTable() {
        console.log('generateTruthTable Ã§aÄŸrÄ±ldÄ±');
        const rows = Math.pow(2, this.variableCount);
        this.truthTable = [];
        
        // KarnoValues array'ini doÄŸru boyutta initialize et
        this.karnoValues = new Array(rows).fill(0);
        
        for (let i = 0; i < rows; i++) {
            const row = {};
            for (let j = 0; j < this.variableCount; j++) {
                const varName = this.variables[j];
                row[varName] = (i >> (this.variableCount - 1 - j)) & 1;
            }
            row.output = 0; // Default output
            row.minterm = i;
            this.truthTable.push(row);
        }

        console.log('DoÄŸruluk tablosu oluÅŸturuldu:', this.truthTable);
        console.log('KarnoValues initialize edildi:', this.karnoValues);
        this.renderTruthTable();
        this.updateKarnoFromTruthTable();
    }

    renderTruthTable() {
        console.log('renderTruthTable Ã§aÄŸrÄ±ldÄ±');
        const container = document.getElementById('truthTableContainer');
        console.log('Container bulundu:', container);
        
        if (!container) {
            console.error('truthTableContainer bulunamadÄ±!');
            return;
        }
        
        let html = '<table class="truth-table"><thead><tr>';
        
        // Variable headers
        for (const variable of this.variables) {
            html += `<th>${variable}</th>`;
        }
        html += '<th>F</th></tr></thead><tbody>';

        // Table rows
        for (let i = 0; i < this.truthTable.length; i++) {
            const row = this.truthTable[i];
            html += '<tr>';
            
            for (const variable of this.variables) {
                html += `<td>${row[variable]}</td>`;
            }
            
            const outputClass = row.output === 1 ? 'selected' : 
                               row.output === 'X' ? 'dont-care' : '';
            
            html += `<td class="output-cell ${outputClass}" 
                     data-row="${i}" onclick="karnoApp.toggleOutput(${i})">
                     ${row.output}
                   </td>`;
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
        console.log('DoÄŸruluk tablosu render edildi');
    }

    toggleOutput(rowIndex) {
        console.log('toggleOutput Ã§aÄŸrÄ±ldÄ±, rowIndex:', rowIndex);
        const currentValue = this.truthTable[rowIndex].output;
        // 0 -> 1 -> X -> 0 dÃ¶ngÃ¼sÃ¼
        if (currentValue === 0) {
            this.truthTable[rowIndex].output = 1;
        } else if (currentValue === 1) {
            this.truthTable[rowIndex].output = 'X';
        } else {
            this.truthTable[rowIndex].output = 0;
        }
        this.renderTruthTable();
        this.updateKarnoFromTruthTable();
        this.clearResults();
        
        // Otomatik grup bulma kaldÄ±rÄ±ldÄ± - kullanÄ±cÄ± manuel olarak butsona basacak
        console.log('ğŸ’¡ DeÄŸiÅŸiklik yapÄ±ldÄ±, gruplarÄ± bulmak iÃ§in "GruplarÄ± Bul" butonuna basÄ±n');
    }

    updateKarnoFromTruthTable() {
        this.karnoValues = this.truthTable.map(row => row.output);
        this.renderKarnoMap();
    }

    generateKarnoMap() {
        console.log('generateKarnoMap Ã§aÄŸrÄ±ldÄ±');
        const container = document.getElementById('karnoMapContainer');
        console.log('Karno container bulundu:', container);
        
        if (!container) {
            console.error('karnoMapContainer bulunamadÄ±!');
            return;
        }
        
        if (this.variableCount === 2) {
            this.generateKarno2Var(container);
        } else if (this.variableCount === 3) {
            this.generateKarno3Var(container);
        } else if (this.variableCount === 4) {
            this.generateKarno4Var(container);
        }
    }

    generateKarno2Var(container) {
        console.log('2 deÄŸiÅŸkenli Karno haritasÄ± oluÅŸturuluyor');
        let html = `
            <div class="karno-map map-2var">
                <div class="karno-labels">
                    <div class="label-top" style="position: absolute; top: -35px; left: 20px; display: flex; justify-content: space-around; width: 120px;">
                        <span>0</span><span>1</span>
                    </div>
                    <div class="label-top" style="position: absolute; top: -50px; left: 0; right: 0; text-align: center; font-weight: bold;">B</div>
                    <div class="label-left" style="position: absolute; left: -35px; top: 20px; display: flex; flex-direction: column; justify-content: space-around; height: 120px;">
                        <span>0</span><span>1</span>
                    </div>
                    <div class="label-left" style="position: absolute; left: -50px; top: 0; bottom: 0; writing-mode: vertical-lr; display: flex; align-items: center; font-weight: bold;">A</div>
                </div>
        `;

        // 2 deÄŸiÅŸken Gray code: A\B: 0, 1
        const order = [0, 1, 3, 2]; // A=0,B=0; A=0,B=1; A=1,B=1; A=1,B=0

        for (let i = 0; i < 4; i++) {
            const minterm = order[i];
            html += `<div class="karno-cell" data-minterm="${minterm}">
                       <div class="minterm-label">m${minterm}</div>
                       <span class="cell-value">${this.karnoValues[minterm] || 0}</span>
                     </div>`;
        }

        html += '</div>';
        container.innerHTML = html;
        
        // Event listener'larÄ± JavaScript ile ekle
        this.addCellEventListeners();
    }

    generateKarno3Var(container) {
        console.log('3 deÄŸiÅŸkenli Karno haritasÄ± oluÅŸturuluyor');
        let html = `
            <div class="karno-map map-3var">
                <div class="karno-labels">
                    <div class="label-top" style="position: absolute; top: -35px; left: 20px; display: flex; justify-content: space-around; width: 240px;">
                        <span>00</span><span>01</span><span>11</span><span>10</span>
                    </div>
                    <div class="label-top" style="position: absolute; top: -50px; left: 0; right: 0; text-align: center; font-weight: bold;">BC</div>
                    <div class="label-left" style="position: absolute; left: -35px; top: 20px; display: flex; flex-direction: column; justify-content: space-around; height: 120px;">
                        <span>0</span><span>1</span>
                    </div>
                    <div class="label-left" style="position: absolute; left: -50px; top: 0; bottom: 0; writing-mode: vertical-lr; display: flex; align-items: center; font-weight: bold;">A</div>
                </div>
        `;

        // 3 deÄŸiÅŸken Gray code: A\BC: 00, 01, 11, 10
        const order = [
            0, 1, 3, 2,  // A=0: BC=00,01,11,10
            4, 5, 7, 6   // A=1: BC=00,01,11,10
        ];

        for (let i = 0; i < 8; i++) {
            const minterm = order[i];
            html += `<div class="karno-cell" data-minterm="${minterm}">
                       <div class="minterm-label">m${minterm}</div>
                       <span class="cell-value">${this.karnoValues[minterm] || 0}</span>
                     </div>`;
        }

        html += '</div>';
        container.innerHTML = html;
        
        // Event listener'larÄ± JavaScript ile ekle
        this.addCellEventListeners();
    }

    generateKarno4Var(container) {
        console.log('4 deÄŸiÅŸkenli Karno haritasÄ± oluÅŸturuluyor');
        console.log('Container mevcut:', container);
        console.log('KarnoValues durumu:', this.karnoValues);
        
        let html = `
            <div class="karno-map map-4var">
                <div class="karno-labels">
                    <div class="label-top" style="position: absolute; top: -35px; left: 20px; display: flex; justify-content: space-around; width: 240px;">
                        <span>00</span><span>01</span><span>11</span><span>10</span>
                    </div>
                    <div class="label-top" style="position: absolute; top: -50px; left: 0; right: 0; text-align: center; font-weight: bold;">CD</div>
                    <div class="label-left" style="position: absolute; left: -35px; top: 20px; display: flex; flex-direction: column; justify-content: space-around; height: 240px;">
                        <span>00</span><span>01</span><span>11</span><span>10</span>
                    </div>
                    <div class="label-left" style="position: absolute; left: -50px; top: 0; bottom: 0; writing-mode: vertical-lr; display: flex; align-items: center; font-weight: bold;">AB</div>
                </div>
        `;

        // Gray code sÄ±ralamasÄ±: AB\CD: 00, 01, 11, 10
        const order = [
            0,  1,  3,  2,   // AB=00: CD=00,01,11,10
            4,  5,  7,  6,   // AB=01: CD=00,01,11,10
            12, 13, 15, 14,  // AB=11: CD=00,01,11,10
            8,  9,  11, 10   // AB=10: CD=00,01,11,10
        ];

        for (let i = 0; i < 16; i++) {
            const minterm = order[i];
            const value = this.karnoValues[minterm] || 0;
            html += `<div class="karno-cell" data-minterm="${minterm}">
                       <div class="minterm-label">m${minterm}</div>
                       <span class="cell-value">${value}</span>
                     </div>`;
        }

        html += '</div>';
        container.innerHTML = html;
        console.log('4 deÄŸiÅŸkenli Karno haritasÄ± HTML\'e eklendi');
        
        // Event listener'larÄ± JavaScript ile ekle
        this.addCellEventListeners();
    }

    addCellEventListeners() {
        console.log('addCellEventListeners Ã§aÄŸrÄ±ldÄ±');
        const cells = document.querySelectorAll('.karno-cell');
        console.log('Bulunan hÃ¼cre sayÄ±sÄ±:', cells.length);
        
        cells.forEach(cell => {
            const minterm = parseInt(cell.dataset.minterm);
            console.log('Event listener ekleniyor, minterm:', minterm);
            
            // Click event
            cell.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('HÃ¼cre tÄ±klandÄ±, minterm:', minterm);
                this.toggleKarnoCell(minterm);
            });
            
            // Mouse events
            cell.addEventListener('mouseenter', (e) => {
                this.highlightCellGroups(minterm);
            });
            
            cell.addEventListener('mouseleave', (e) => {
                this.removeCellGroupHighlight();
            });
            
            // HÃ¼creyi clickable yap
            cell.style.cursor = 'pointer';
        });
    }

    toggleKarnoCell(minterm) {
        console.log('toggleKarnoCell Ã§aÄŸrÄ±ldÄ±, minterm:', minterm);
        
        // Gruplar bulunduktan sonra minterm giriÅŸi engelle
        if (this.isLocked && this.hasGroups) {
            this.showLockMessage();
            return;
        }
        
        console.log('Mevcut karnoValues:', this.karnoValues);
        
        const currentValue = this.karnoValues[minterm] || 0;
        console.log('Mevcut deÄŸer:', currentValue);
        
        // 0 -> 1 -> X -> 0 dÃ¶ngÃ¼sÃ¼  
        if (currentValue === 0) {
            this.karnoValues[minterm] = 1;
        } else if (currentValue === 1) {
            this.karnoValues[minterm] = 'X';
        } else {
            this.karnoValues[minterm] = 0;
        }
        
        this.truthTable[minterm].output = this.karnoValues[minterm];
        this.renderTruthTable();
        this.renderKarnoMap();
        this.clearResults();
        
        // Otomatik grup bulma kaldÄ±rÄ±ldÄ± - kullanÄ±cÄ± manuel olarak butsona basacak
        console.log('ğŸ’¡ HÃ¼cre deÄŸiÅŸtirildi, gruplarÄ± bulmak iÃ§in "GruplarÄ± Bul" butonuna basÄ±n');
    }

    renderKarnoMap() {
        console.log('renderKarnoMap Ã§aÄŸrÄ±ldÄ±');
        const cells = document.querySelectorAll('.karno-cell');
        console.log('Bulunan Karno hÃ¼creleri:', cells.length);
        console.log('KarnoValues durumu:', this.karnoValues);
        
        if (cells.length === 0) {
            console.error('Karno hÃ¼creleri bulunamadÄ±! generateKarnoMap Ã§alÄ±ÅŸmamÄ±ÅŸ olabilir.');
            return;
        }
        
        cells.forEach(cell => {
            const minterm = parseInt(cell.dataset.minterm);
            const value = this.karnoValues[minterm] || 0;
            const valueSpan = cell.querySelector('.cell-value');
            if (valueSpan) {
                valueSpan.textContent = value;
            }
            
            // HÃ¼cre stillerini gÃ¼ncelle
            cell.classList.remove('filled', 'dont-care');
            if (value === 1) {
                cell.classList.add('filled');
            } else if (value === 'X') {
                cell.classList.add('dont-care');
            }
        });
        
        console.log('Karno haritasÄ± render edildi');
    }

    // GeliÅŸmiÅŸ grup vurgulama - tam grup dominasyonu (gÃ¼Ã§lÃ¼ renk temizleme)
    highlightCellGroups(minterm) {
        console.log('highlightCellGroups Ã§aÄŸrÄ±ldÄ±, minterm:', minterm);
        
        // Bu hÃ¼creyi iÃ§eren gruplarÄ± bul
        const containingGroups = this.groups.filter(group => 
            group.minterms.includes(minterm)
        );
        
        if (containingGroups.length === 0) return;
        
        // ADIM 1: TÃœM hover ve grup renklerini kesinlikle kaldÄ±r
        document.querySelectorAll('.karno-cell').forEach(cell => {
            cell.classList.remove('highlight-hover');
            // TÃ¼m olasÄ± grup sÄ±nÄ±flarÄ±nÄ± kaldÄ±r
            for (let i = 1; i <= 6; i++) {
                cell.classList.remove(`group-${i}`);
                cell.classList.remove(`group-${i}-hover`);
            }
            // Ek temizlik - olasÄ± diÄŸer renk sÄ±nÄ±flarÄ±
            cell.classList.remove('group-highlight', 'group-hover', 'selected');
        });
        
        // ADIM 2: Dominant grubu belirle
        const dominantGroup = containingGroups.reduce((best, current) => {
            const bestPriority = this.getGroupPriority(best, minterm);
            const currentPriority = this.getGroupPriority(current, minterm);
            return currentPriority > bestPriority ? current : best;
        });
        
        const dominantGroupIndex = this.groups.indexOf(dominantGroup);
        const dominantGroupClass = `group-${(dominantGroupIndex % 6) + 1}`;
        
        console.log(`Dominant grup: index=${dominantGroupIndex}, class=${dominantGroupClass}`);
        
        // ADIM 3: Ã–nce dominant grubun TÃœM hÃ¼crelerini vurgula
        dominantGroup.minterms.forEach(mt => {
            const cell = document.querySelector(`[data-minterm="${mt}"]`);
            if (cell) {
                // Ã‡ifte temizlik
                for (let i = 1; i <= 6; i++) {
                    cell.classList.remove(`group-${i}`);
                    cell.classList.remove(`group-${i}-hover`);
                }
                // Dominant rengi uygula
                cell.classList.add(`${dominantGroupClass}-hover`);
                console.log(`HÃ¼cre ${mt} -> ${dominantGroupClass}-hover eklendi`);
            }
        });
        
        // ADIM 4: DiÄŸer gruplarÄ± sadece kesiÅŸmeyen bÃ¶lgelerde gÃ¶ster
        this.groups.forEach((group, index) => {
            if (group === dominantGroup) return; // Dominant grubu atla
            
            const groupClass = `group-${(index % 6) + 1}`;
            
            group.minterms.forEach(mt => {
                const cell = document.querySelector(`[data-minterm="${mt}"]`);
                if (!cell) return;
                
                // Bu hÃ¼cre dominant grubun parÃ§asÄ± mÄ±?
                if (!dominantGroup.minterms.includes(mt)) {
                    // KesiÅŸmiyor - bu grubun rengini gÃ¼venle ekle
                    cell.classList.add(`${groupClass}-hover`);
                    console.log(`KesiÅŸmeyen hÃ¼cre ${mt} -> ${groupClass}-hover eklendi`);
                } else {
                    console.log(`KesiÅŸen hÃ¼cre ${mt} -> renk atlandÄ± (dominant grup hakim)`);
                }
            });
        });
        
        // ADIM 5: Mouse'un geldiÄŸi hÃ¼creyi Ã¶zel vurgula
        const hoveredCell = document.querySelector(`[data-minterm="${minterm}"]`);
        if (hoveredCell) {
            hoveredCell.classList.add('highlight-hover');
            console.log(`Hover hÃ¼cresi ${minterm} -> highlight-hover eklendi`);
        }
    }

    removeCellGroupHighlight() {
        console.log('removeCellGroupHighlight Ã§aÄŸrÄ±ldÄ± - gÃ¼Ã§lÃ¼ temizlik');
        
        // TÃ¼m hover highlight'larÄ±nÄ± kesinlikle kaldÄ±r
        document.querySelectorAll('.karno-cell').forEach(cell => {
            cell.classList.remove('highlight-hover');
            
            // TÃ¼m olasÄ± grup sÄ±nÄ±flarÄ±nÄ± kaldÄ±r
            for (let i = 1; i <= 6; i++) {
                cell.classList.remove(`group-${i}`);
                cell.classList.remove(`group-${i}-hover`);
            }
            
            // Ek temizlik - olasÄ± diÄŸer hover sÄ±nÄ±flarÄ±
            cell.classList.remove('group-highlight', 'group-hover', 'selected', 'cell-hover');
            
            // Style attribute'ta inline renkler varsa onlarÄ± da kaldÄ±r
            if (cell.style.backgroundColor) {
                cell.style.backgroundColor = '';
            }
            if (cell.style.borderColor) {
                cell.style.borderColor = '';
            }
        });
        
        console.log('TÃ¼m hover efektleri temizlendi');
    }

    clearResults() {
        this.groups = [];
        this.hasGroups = false; // Grup durumunu sÄ±fÄ±rla
        this.unlockMap(); // Kilitlemeyi kaldÄ±r
        
        const groupsList = document.getElementById('groupsList');
        if (groupsList) {
            groupsList.innerHTML = '<p style="color: #6b7280; font-style: italic;">HenÃ¼z grup bulunamadÄ±. "GruplarÄ± Bul" butonuna tÄ±klayÄ±n.</p>';
        }
        
        const solutionDisplay = document.getElementById('solutionDisplay');
        if (solutionDisplay) {
            solutionDisplay.textContent = '';
        }
        
        const termCount = document.getElementById('termCount');
        if (termCount) {
            termCount.textContent = 'Terim sayÄ±sÄ±: 0';
        }
        
        const literalCount = document.getElementById('literalCount');
        if (literalCount) {
            literalCount.textContent = 'Literal sayÄ±sÄ±: 0';
        }
        
        // Remove group highlighting
        document.querySelectorAll('.karno-cell').forEach(cell => {
            for (let i = 1; i <= 6; i++) {
                cell.classList.remove(`group-${i}`);
            }
        });
        
        // Etiket vurgularÄ±nÄ± da temizle
        this.clearLabelHighlights();
    }

    clearAll() {
        // TÃ¼m deÄŸerleri sÄ±fÄ±rla
        this.karnoValues = [];
        this.truthTable.forEach(row => {
            row.output = 0;
        });
        this.renderTruthTable();
        this.renderKarnoMap();
        this.clearResults();
    }

    generateRandom() {
        // Rastgele deÄŸerler ata
        this.truthTable.forEach(row => {
            row.output = Math.random() < 0.3 ? 1 : 0; // %30 ÅŸansla 1
        });
        this.updateKarnoFromTruthTable();
        this.clearResults();
        
        // Otomatik grup bulma kaldÄ±rÄ±ldÄ± - kullanÄ±cÄ± manuel olarak butsona basacak
        console.log('ğŸ² Rastgele deÄŸerler oluÅŸturuldu, gruplarÄ± bulmak iÃ§in "GruplarÄ± Bul" butonuna basÄ±n');
        setTimeout(() => {
            this.findGroups(); // Bu da artÄ±k otomatik olarak showSolution() Ã§aÄŸÄ±racak
        }, 100);
    }

    applyMinterms() {
        const mintermsInput = document.getElementById('mintermsInput');
        const dontCareInput = document.getElementById('dontCareInput');
        
        if (!mintermsInput) return;
        
        // Ã–nce tÃ¼mÃ¼nÃ¼ sÄ±fÄ±rla
        this.truthTable.forEach(row => {
            row.output = 0;
        });
        
        // Mintermleri uygula
        if (mintermsInput.value.trim()) {
            const minterms = mintermsInput.value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            minterms.forEach(minterm => {
                if (minterm >= 0 && minterm < this.truthTable.length) {
                    this.truthTable[minterm].output = 1;
                }
            });
        }
        
        // Don't care'leri uygula
        if (dontCareInput && dontCareInput.value.trim()) {
            const dontCares = dontCareInput.value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            dontCares.forEach(minterm => {
                if (minterm >= 0 && minterm < this.truthTable.length) {
                    this.truthTable[minterm].output = 'X';
                }
            });
        }
        
        this.updateKarnoFromTruthTable();
        this.clearResults();
        
        // Otomatik grup bulma kaldÄ±rÄ±ldÄ± - kullanÄ±cÄ± manuel olarak butsona basacak
        console.log('ğŸ’¡ Mintermler uygulandÄ±, gruplarÄ± bulmak iÃ§in "GruplarÄ± Bul" butonuna basÄ±n');
    }

    findGroups() {
        this.groups = [];
        
        // Aktif mintermleri (1'ler) ve don't care'leri (X'ler) bul
        const activeMinterms = this.karnoValues.map((val, idx) => val === 1 ? idx : null)
                                               .filter(idx => idx !== null);
        const dontCareMinterms = this.karnoValues.map((val, idx) => val === 'X' ? idx : null)
                                                 .filter(idx => idx !== null);
        
        // Grup bulma iÃ§in hem 1'leri hem de X'leri kullan
        const allMintermsForGrouping = [...activeMinterms, ...dontCareMinterms];
        
        if (activeMinterms.length === 0) {
            this.displayGroups();
            return;
        }

        // Karno haritasÄ± kurallarÄ±na gÃ¶re gruplarÄ± bul (don't care'ler dahil)
        this.findKarnoGroups(allMintermsForGrouping);
        
        // Sadece aktif mintermleri kapsayan optimal gruplarÄ± seÃ§
        this.selectOptimalGroups(activeMinterms);
        
        this.displayGroups();
        this.highlightGroups();
        
        // Grup etiket analizini yap ve deÄŸiÅŸmeyen deÄŸiÅŸkenleri vurgula
        this.analyzeAndHighlightLabels();
        
        // Gruplar bulunduktan sonra Ã§Ã¶zÃ¼mÃ¼ otomatik gÃ¶ster
        setTimeout(() => {
            this.showSolution();
        }, 500); // GÃ¶rsel efektlerin tamamlanmasÄ± iÃ§in kÄ±sa bir gecikme
        
        // Gruplar bulunduktan sonra kilitleme aktif et
        if (this.groups.length > 0) {
            this.lockMap();
        }
    }

    findKarnoGroups(minterms) {
        // Karno haritasÄ± sadeleÅŸtirme kurallarÄ±nÄ± uygula
        this.allPossibleGroups = [];
        
        if (this.variableCount === 4) {
            this.findAllGroups4Var(minterms);
        } else if (this.variableCount === 3) {
            this.findAllGroups3Var(minterms);
        } else if (this.variableCount === 2) {
            this.findAllGroups2Var(minterms);
        }
        
        // En iyi kapsama kÃ¼mesini bul (Petrick's method basitleÅŸtirilmiÅŸ)
        this.findOptimalCovering(minterms);
    }

    // 4 deÄŸiÅŸkenli harita iÃ§in tÃ¼m geÃ§erli gruplarÄ± bul
    findAllGroups4Var(minterms) {
        // 16'lÄ±k grup (tÃ¼m harita)
        if (minterms.length === 16) {
            this.allPossibleGroups.push({
                minterms: [...minterms],
                size: 16,
                term: '1',
                isPrime: true
            });
            return;
        }

        // 8'lik gruplarÄ± bul
        this.find8Groups4Var(minterms);
        
        // 4'lÃ¼k gruplarÄ± bul
        this.find4Groups4Var(minterms);
        
        // 2'lik gruplarÄ± bul
        this.find2Groups4Var(minterms);
        
        // Tekil hÃ¼creleri bul
        this.find1Groups4Var(minterms);
    }

    find8Groups4Var(minterms) {
        const groups8 = [
            // Yatay yarÄ±lar
            [0, 1, 2, 3, 4, 5, 6, 7],       // Ãœst 2 satÄ±r (AB=0x)
            [8, 9, 10, 11, 12, 13, 14, 15], // Alt 2 satÄ±r (AB=1x)
            
            // Dikey yarÄ±lar
            [0, 1, 4, 5, 8, 9, 12, 13],     // Sol 2 sÃ¼tun (CD=x0)
            [2, 3, 6, 7, 10, 11, 14, 15],   // SaÄŸ 2 sÃ¼tun (CD=x1)
            
            // SatÄ±r Ã§iftleri - A sabit
            [0, 2, 4, 6, 8, 10, 12, 14],    // A=0,C=0 ve A=1,C=0
            [1, 3, 5, 7, 9, 11, 13, 15],    // A=0,C=1 ve A=1,C=1
            
            // DeÄŸiÅŸken bazlÄ± 8'li gruplar
            [1, 3, 5, 7, 9, 11, 13, 15],    // D=1 (tÃ¼m tek sayÄ±lar)
            [0, 2, 4, 6, 8, 10, 12, 14],    // D=0 (tÃ¼m Ã§ift sayÄ±lar)
            [4, 5, 6, 7, 12, 13, 14, 15],   // B=1 (tÃ¼m B=1 durumlarÄ±)
            [0, 1, 2, 3, 8, 9, 10, 11],     // B=0 (tÃ¼m B=0 durumlarÄ±)
            [2, 3, 6, 7, 10, 11, 14, 15],   // C=1 (tÃ¼m C=1 durumlarÄ±)
            [0, 1, 4, 5, 8, 9, 12, 13],     // C=0 (tÃ¼m C=0 durumlarÄ±)
            [8, 9, 10, 11, 12, 13, 14, 15], // A=1 (tÃ¼m A=1 durumlarÄ±)
            [0, 1, 2, 3, 4, 5, 6, 7],       // A=0 (tÃ¼m A=0 durumlarÄ±)
        ];

        for (const group of groups8) {
            if (this.isValidGroup(group, minterms)) {
                this.allPossibleGroups.push({
                    minterms: [...group],
                    size: 8,
                    term: this.generateOptimalTerm(group),
                    isPrime: this.isPrimeImplicant(group, minterms)
                });
            }
        }
    }

    find4Groups4Var(minterms) {
        const groups4 = [
            // 2x2 kare gruplar (Gray code dÃ¼zeni: 00,01,11,10)
            [0, 1, 4, 5],    // Sol Ã¼st kare (AB=00,01, CD=00,01)
            [1, 3, 5, 7],    // SaÄŸ Ã¼st kare (AB=00,01, CD=01,11)  
            [3, 2, 7, 6],    // SaÄŸ orta kare (AB=00,01, CD=11,10)
            [2, 0, 6, 4],    // Sol orta kare - sarma (AB=00,01, CD=10,00)
            
            [4, 5, 12, 13],  // Sol 2. kare (AB=01,11, CD=00,01)
            [5, 7, 13, 15],  // SaÄŸ 2. kare (AB=01,11, CD=01,11)
            [7, 6, 15, 14],  // SaÄŸ 3. kare (AB=01,11, CD=11,10)
            [6, 4, 14, 12],  // Sol 3. kare - sarma (AB=01,11, CD=10,00)
            
            [12, 13, 8, 9],  // Sol alt kare (AB=11,10, CD=00,01)
            [13, 15, 9, 11], // SaÄŸ alt kare (AB=11,10, CD=01,11)
            [15, 14, 11, 10], // SaÄŸ 4. kare (AB=11,10, CD=11,10)
            [14, 12, 10, 8], // Sol 4. kare - sarma (AB=11,10, CD=10,00)
            
            // KÃ¶ÅŸe gruplarÄ± (sarma)
            [0, 2, 8, 10],   // Sol kÃ¶ÅŸe sarmasÄ±
            [1, 3, 9, 11],   // SaÄŸ kÃ¶ÅŸe sarmasÄ±
            
            // Yatay dikdÃ¶rtgen gruplar (1x4)
            [0, 1, 3, 2],    // Ãœst satÄ±r (AB=00)
            [4, 5, 7, 6],    // 2. satÄ±r (AB=01) - Ä°ÅTE BU!
            [12, 13, 15, 14], // 3. satÄ±r (AB=11)
            [8, 9, 11, 10],  // Alt satÄ±r (AB=10)
            
            // Dikey dikdÃ¶rtgen gruplar (4x1)
            [0, 4, 12, 8],   // Sol sÃ¼tun (CD=00)
            [1, 5, 13, 9],   // 2. sÃ¼tun (CD=01)
            [3, 7, 15, 11],  // 3. sÃ¼tun (CD=11)
            [2, 6, 14, 10],  // SaÄŸ sÃ¼tun (CD=10)
        ];

        for (const group of groups4) {
            if (this.isValidGroup(group, minterms)) {
                this.allPossibleGroups.push({
                    minterms: [...group],
                    size: 4,
                    term: this.generateOptimalTerm(group),
                    isPrime: this.isPrimeImplicant(group, minterms)
                });
            }
        }
    }

    find2Groups4Var(minterms) {
        const groups2 = [];
        
        // Yatay komÅŸular (Gray code sÄ±rasÄ±na gÃ¶re)
        const rows = [
            [0, 1, 3, 2],      // 1. satÄ±r (AB=00)
            [4, 5, 7, 6],      // 2. satÄ±r (AB=01)
            [12, 13, 15, 14],  // 3. satÄ±r (AB=11)
            [8, 9, 11, 10]     // 4. satÄ±r (AB=10)
        ];
        
        for (const row of rows) {
            for (let i = 0; i < row.length; i++) {
                const next = (i + 1) % row.length; // SarmalÄ± komÅŸu
                groups2.push([row[i], row[next]]);
            }
        }
        
        // Dikey komÅŸular
        const cols = [
            [0, 4, 12, 8],     // 1. sÃ¼tun
            [1, 5, 13, 9],     // 2. sÃ¼tun
            [3, 7, 15, 11],    // 3. sÃ¼tun
            [2, 6, 14, 10]     // 4. sÃ¼tun
        ];
        
        for (const col of cols) {
            for (let i = 0; i < col.length; i++) {
                const next = (i + 1) % col.length; // SarmalÄ± komÅŸu
                groups2.push([col[i], col[next]]);
            }
        }

        for (const group of groups2) {
            if (this.isValidGroup(group, minterms)) {
                this.allPossibleGroups.push({
                    minterms: [...group],
                    size: 2,
                    term: this.generateOptimalTerm(group),
                    isPrime: this.isPrimeImplicant(group, minterms)
                });
            }
        }
    }

    find1Groups4Var(minterms) {
        for (const minterm of minterms) {
            this.allPossibleGroups.push({
                minterms: [minterm],
                size: 1,
                term: this.generateOptimalTerm([minterm]),
                isPrime: this.isPrimeImplicant([minterm], minterms)
            });
        }
    }

    // 3 deÄŸiÅŸkenli harita iÃ§in tÃ¼m geÃ§erli gruplarÄ± bul
    findAllGroups3Var(minterms) {
        if (minterms.length === 8) {
            this.allPossibleGroups.push({
                minterms: [...minterms],
                size: 8,
                term: '1',
                isPrime: true
            });
            return;
        }

        this.find4Groups3Var(minterms);
        this.find2Groups3Var(minterms);
        this.find1Groups3Var(minterms);
    }

    find4Groups3Var(minterms) {
        const groups4 = [
            // Tam satÄ±rlar (Gray code sÄ±rasÄ±nda)
            [0, 1, 3, 2],    // Ãœst satÄ±r (A=0, BC=00,01,11,10)
            [4, 5, 7, 6],    // Alt satÄ±r (A=1, BC=00,01,11,10)
            
            // 2x2 kare gruplar (dikey komÅŸu Ã§iftler)
            [0, 1, 4, 5],    // Sol kare (BC=00,01)
            [1, 3, 5, 7],    // Orta kare (BC=01,11)
            [3, 2, 7, 6],    // SaÄŸ kare (BC=11,10)
            [2, 0, 6, 4],    // Sarma kare (BC=10,00) - sol-saÄŸ sarma
            
            // Dikey sÃ¼tun Ã§iftleri (sarmalÄ±)
            [0, 2, 4, 6],    // 1. ve 3. sÃ¼tun (BC=00,10)
            [1, 3, 5, 7],    // 2. ve 4. sÃ¼tun (BC=01,11)
        ];

        for (const group of groups4) {
            if (this.isValidGroup(group, minterms)) {
                this.allPossibleGroups.push({
                    minterms: [...group],
                    size: 4,
                    term: this.generateOptimalTerm(group),
                    isPrime: this.isPrimeImplicant(group, minterms)
                });
            }
        }
    }

    find2Groups3Var(minterms) {
        const groups2 = [];
        
        // Yatay komÅŸular (Gray code sÄ±rasÄ±na gÃ¶re)
        const rows = [
            [0, 1, 3, 2],      // Ãœst satÄ±r (A=0)
            [4, 5, 7, 6]       // Alt satÄ±r (A=1)
        ];
        
        for (const row of rows) {
            for (let i = 0; i < row.length; i++) {
                const next = (i + 1) % row.length;
                groups2.push([row[i], row[next]]);
            }
        }
        
        // Dikey komÅŸular
        groups2.push([0, 4], [1, 5], [3, 7], [2, 6]);

        for (const group of groups2) {
            if (this.isValidGroup(group, minterms)) {
                this.allPossibleGroups.push({
                    minterms: [...group],
                    size: 2,
                    term: this.generateOptimalTerm(group),
                    isPrime: this.isPrimeImplicant(group, minterms)
                });
            }
        }
    }

    find1Groups3Var(minterms) {
        for (const minterm of minterms) {
            this.allPossibleGroups.push({
                minterms: [minterm],
                size: 1,
                term: this.generateOptimalTerm([minterm]),
                isPrime: this.isPrimeImplicant([minterm], minterms)
            });
        }
    }

    // 2 deÄŸiÅŸkenli harita iÃ§in tÃ¼m geÃ§erli gruplarÄ± bul
    findAllGroups2Var(minterms) {
        if (minterms.length === 4) {
            this.allPossibleGroups.push({
                minterms: [...minterms],
                size: 4,
                term: '1',
                isPrime: true
            });
            return;
        }

        this.find2Groups2Var(minterms);
        this.find1Groups2Var(minterms);
    }

    find2Groups2Var(minterms) {
        const groups2 = [
            [0, 1], // Ãœst satÄ±r (A=0)
            [2, 3], // Alt satÄ±r (A=1)
            [0, 2], // Sol sÃ¼tun (B=0)
            [1, 3], // SaÄŸ sÃ¼tun (B=1)
        ];

        for (const group of groups2) {
            if (this.isValidGroup(group, minterms)) {
                this.allPossibleGroups.push({
                    minterms: [...group],
                    size: 2,
                    term: this.generateOptimalTerm(group),
                    isPrime: this.isPrimeImplicant(group, minterms)
                });
            }
        }
    }

    find1Groups2Var(minterms) {
        for (const minterm of minterms) {
            this.allPossibleGroups.push({
                minterms: [minterm],
                size: 1,
                term: this.generateOptimalTerm([minterm]),
                isPrime: this.isPrimeImplicant([minterm], minterms)
            });
        }
    }

    // Bir grubun geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± kontrol et
    isValidGroup(group, minterms) {
        return group.every(minterm => minterms.includes(minterm));
    }

    // Prime implicant kontrolÃ¼
    isPrimeImplicant(group, allMinterms) {
        // Bir grup prime implicant'tÄ±r eÄŸer daha bÃ¼yÃ¼k bir gruba geniÅŸletilemiyorsa
        for (const possibleGroup of this.allPossibleGroups) {
            if (possibleGroup.size > group.length && 
                group.every(minterm => possibleGroup.minterms.includes(minterm))) {
                return false;
            }
        }
        return true;
    }

    // Optimal kapsama bulma (Petrick's method basitleÅŸtirilmiÅŸ)
    findOptimalCovering(minterms) {
        console.log('ğŸ” Optimal grup kapsama baÅŸlatÄ±lÄ±yor...');
        console.log('Bulunan tÃ¼m gruplar:', this.allPossibleGroups);
        
        // Ã–nce gruplarÄ± boyut ve Ã¶ncelik sÄ±rasÄ±na gÃ¶re sÄ±rala (bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe)
        const sortedGroups = this.allPossibleGroups
            .filter(group => group.minterms.some(m => minterms.includes(m))) // Sadece ilgili gruplarÄ± al
            .sort((a, b) => {
                // 1. Ã–ncelik: Grup boyutu (bÃ¼yÃ¼k gruplar Ã¶nce)
                if (a.size !== b.size) return b.size - a.size;
                // 2. Ã–ncelik: KapsadÄ±ÄŸÄ± minterm sayÄ±sÄ±
                const aRelevant = a.minterms.filter(m => minterms.includes(m)).length;
                const bRelevant = b.minterms.filter(m => minterms.includes(m)).length;
                return bRelevant - aRelevant;
            });
        
        console.log('SÄ±ralanmÄ±ÅŸ gruplar:', sortedGroups);
        
        // Greedy yaklaÅŸÄ±mla optimal kapsama bul
        const selectedGroups = [];
        const coveredMinterms = new Set();
        const targetMinterms = new Set(minterms.filter(m => this.karnoValues[m] === 1)); // Sadece 1'leri kapsa
        
        console.log('Kaplanacak mintermler:', Array.from(targetMinterms));
        
        for (const group of sortedGroups) {
            // Bu grup yeni mintermler kapsÄ±yor mu?
            const newMinterms = group.minterms.filter(m => 
                targetMinterms.has(m) && !coveredMinterms.has(m)
            );
            
            if (newMinterms.length > 0) {
                selectedGroups.push(group);
                group.minterms.forEach(m => {
                    if (targetMinterms.has(m)) {
                        coveredMinterms.add(m);
                    }
                });
                
                console.log(`âœ… Grup seÃ§ildi: ${group.size}'lÃ¼ grup, yeni mintermler: [${newMinterms.join(',')}]`);
                console.log(`   Kapsanan toplam: [${Array.from(coveredMinterms).join(',')}]`);
                
                // TÃ¼m mintermler kaplandÄ± mÄ±?
                if (coveredMinterms.size === targetMinterms.size) {
                    console.log('ğŸ¯ TÃ¼m mintermler kaplandÄ±!');
                    break;
                }
            }
        }
        
        // Sonucu ata
        this.groups = selectedGroups.map((group, index) => ({
            ...group,
            id: index + 1,
            color: this.getGroupColor(index)
        }));
        
        console.log('âœ… SeÃ§ilen optimal gruplar:', this.groups);
    }

    // Essential prime implicant'larÄ± bul
    findEssentialPrimeImplicants(minterms, primeImplicants) {
        const essential = [];
        const coveredMinterms = new Set();
        
        for (const minterm of minterms) {
            const coveringGroups = primeImplicants.filter(group => 
                group.minterms.includes(minterm)
            );
            
            if (coveringGroups.length === 1) {
                const essentialGroup = coveringGroups[0];
                if (!essential.includes(essentialGroup)) {
                    essential.push(essentialGroup);
                    essentialGroup.minterms.forEach(m => coveredMinterms.add(m));
                }
            }
        }
        
        return essential;
    }

    // Minimal kapsama bulma (greedy approach)
    findMinimalCovering(minterms, primeImplicants, essentialPrimes) {
        const selected = [...essentialPrimes];
        const coveredMinterms = new Set();
        
        // Essential prime'larÄ±n kapsadÄ±ÄŸÄ± mintermleri iÅŸaretle
        essentialPrimes.forEach(group => {
            group.minterms.forEach(m => coveredMinterms.add(m));
        });
        
        // Kalan mintermleri greedy algoritma ile kapsa
        const remainingPrimes = primeImplicants.filter(group => !selected.includes(group));
        
        while (coveredMinterms.size < minterms.length && remainingPrimes.length > 0) {
            // En Ã§ok yeni minterm kapsayan grubu seÃ§
            let bestGroup = null;
            let maxNewCoverage = 0;
            
            for (const group of remainingPrimes) {
                const newCoverage = group.minterms.filter(m => 
                    minterms.includes(m) && !coveredMinterms.has(m)
                ).length;
                
                if (newCoverage > maxNewCoverage) {
                    maxNewCoverage = newCoverage;
                    bestGroup = group;
                }
            }
            
            if (bestGroup && maxNewCoverage > 0) {
                selected.push(bestGroup);
                bestGroup.minterms.forEach(m => {
                    if (minterms.includes(m)) {
                        coveredMinterms.add(m);
                    }
                });
                
                const index = remainingPrimes.indexOf(bestGroup);
                remainingPrimes.splice(index, 1);
            } else {
                break;
            }
        }
        
        this.allPossibleGroups = selected;
    }

    selectOptimalGroups(activeMinterms) {
        // Sadece aktif mintermleri kapsayan gruplarÄ± seÃ§
        const coveredMinterms = new Set();
        const selectedGroups = [];
        
        // Boyuta gÃ¶re sÄ±rala (bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe)
        const sortedGroups = this.allPossibleGroups.sort((a, b) => b.size - a.size);
        
        for (const group of sortedGroups) {
            // Bu grubun yeni aktif mintermleri kapsayÄ±p kapsamadÄ±ÄŸÄ±nÄ± kontrol et
            const uncoveredActiveInGroup = group.minterms.filter(m => 
                activeMinterms.includes(m) && !coveredMinterms.has(m)
            );
            
            if (uncoveredActiveInGroup.length > 0) {
                selectedGroups.push(group);
                // Sadece aktif mintermleri kaplandÄ± olarak iÅŸaretle
                uncoveredActiveInGroup.forEach(m => coveredMinterms.add(m));
                
                // TÃ¼m aktif mintermler kaplandÄ±ysa dur
                if (coveredMinterms.size === activeMinterms.length) {
                    break;
                }
            }
        }

        this.groups = selectedGroups;
    }

    // Grup rengi dÃ¶ndÃ¼r
    getGroupColor(index) {
        const colors = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', 
            '#ffeaa7', '#dda0dd', '#98d8c8', '#f39c12'
        ];
        return colors[index % colors.length];
    }

    generateOptimalTerm(minterms) {
        if (minterms.length === 1) {
            // Tek minterm iÃ§in tam terim oluÅŸtur
            const minterm = minterms[0];
            const binary = minterm.toString(2).padStart(this.variableCount, '0');
            let term = '';
            
            for (let i = 0; i < this.variableCount; i++) {
                if (term.length > 0) term += '';
                if (binary[i] === '1') {
                    term += this.variables[i];
                } else {
                    term += this.variables[i] + "'";
                }
            }
            return term;
        } else {
            // Grup iÃ§in ortak olmayan deÄŸiÅŸkenleri Ã§Ä±kar
            const binaryTerms = minterms.map(m => 
                m.toString(2).padStart(this.variableCount, '0')
            );
            
            let term = '';
            for (let i = 0; i < this.variableCount; i++) {
                const firstBit = binaryTerms[0][i];
                const allSame = binaryTerms.every(binary => binary[i] === firstBit);
                
                if (allSame) {
                    if (term.length > 0) term += '';
                    if (firstBit === '1') {
                        term += this.variables[i];
                    } else {
                        term += this.variables[i] + "'";
                    }
                }
            }
            
            return term || '1';
        }
    }

    displayGroups() {
        const groupsList = document.getElementById('groupsList');
        if (!groupsList) return;
        
        if (this.groups.length === 0) {
            groupsList.innerHTML = '<p style="color: #6b7280; font-style: italic;">HenÃ¼z grup bulunamadÄ±. "GruplarÄ± Bul" butonuna tÄ±klayÄ±n.</p>';
            return;
        }

        let html = '';
        this.groups.forEach((group, index) => {
            const colorClass = `group-color-${(index % 6) + 1}`;
            
            // Bu grup iÃ§in invariant deÄŸiÅŸkenleri bul
            const invariants = this.findInvariantVariables(group);
            
            // DeÄŸiÅŸken durumlarÄ±nÄ± gÃ¶ster
            let variableStatus = '';
            this.variables.forEach(varName => {
                if (invariants.hasOwnProperty(varName)) {
                    // Sabit deÄŸiÅŸken (yeÅŸil)
                    const value = invariants[varName];
                    variableStatus += `<span style="color: #22c55e; font-weight: bold;">${varName}=${value}</span> `;
                } else {
                    // DeÄŸiÅŸken olan (kÄ±rmÄ±zÄ±)
                    variableStatus += `<span style="color: #ef4444; font-weight: bold;">${varName}=deÄŸiÅŸken</span> `;
                }
            });
            
            html += `
                <div class="group-item ${colorClass}" data-group-index="${index}">
                    <div class="group-header">
                        <span class="group-size">Boyut: ${group.size}</span>
                        <span class="group-term">${group.term}</span>
                    </div>
                    <div class="group-variables" style="font-size: 0.9em; margin: 8px 0;">
                        <strong>DeÄŸiÅŸkenler:</strong> ${variableStatus}
                        <br><small style="color: #6b7280;">ğŸŸ¢ Sabit deÄŸerler, ğŸ”´ DeÄŸiÅŸken deÄŸerler (son terimde yer almaz)</small>
                    </div>
                    <div class="group-minterms">
                        Mintermler: ${group.minterms.join(', ')}
                    </div>
                </div>
            `;
        });
        
        groupsList.innerHTML = html;
        
        // Grup hover eventlerini ekle
        document.querySelectorAll('.group-item').forEach(item => {
            item.addEventListener('mouseenter', (e) => {
                const groupIndex = parseInt(e.currentTarget.dataset.groupIndex);
                this.highlightGroup(groupIndex);
            });
            
            item.addEventListener('mouseleave', () => {
                this.removeCellGroupHighlight();
            });
            
            // Grup tÄ±klama event'i ekle
            item.addEventListener('click', (e) => {
                const groupIndex = parseInt(e.currentTarget.dataset.groupIndex);
                const group = this.groups[groupIndex];
                if (group) {
                    this.highlightGroupOnClick(group.id);
                }
            });
        });
    }

    highlightGroups() {
        // Remove existing group highlighting
        document.querySelectorAll('.karno-cell').forEach(cell => {
            for (let i = 1; i <= 6; i++) {
                cell.classList.remove(`group-${i}-hover`);
            }
        });

        // Add new group highlighting
        this.groups.forEach((group, index) => {
            group.minterms.forEach(minterm => {
                const cell = document.querySelector(`[data-minterm="${minterm}"]`);
                if (cell) {
                    cell.classList.add(`group-${(index % 6) + 1}`);
                }
            });
        });
    }

    highlightGroup(groupIndex) {
        // TÃ¼m hover highlight'larÄ±nÄ± kaldÄ±r
        document.querySelectorAll('.karno-cell').forEach(cell => {
            for (let i = 1; i <= 6; i++) {
                cell.classList.remove(`group-${i}-hover`);
            }
        });
        
        if (groupIndex >= 0 && groupIndex < this.groups.length) {
            const group = this.groups[groupIndex];
            const groupClass = `group-${(groupIndex % 6) + 1}`;
            
            group.minterms.forEach(minterm => {
                const cell = document.querySelector(`[data-minterm="${minterm}"]`);
                if (cell) {
                    cell.classList.add(`${groupClass}-hover`);
                }
            });
        }
    }

    // Kilitleme fonksiyonlarÄ±
    lockMap() {
        this.isLocked = true;
        this.hasGroups = true;
        
        // HÃ¼crelere kilitli gÃ¶rÃ¼nÃ¼m ekle
        document.querySelectorAll('.karno-cell').forEach(cell => {
            cell.classList.add('locked');
            cell.style.cursor = 'not-allowed';
        });
        
        console.log('ğŸ”’ Karno haritasÄ± kilitlendi - grup oluÅŸturma tamamlandÄ±');
    }
    
    unlockMap() {
        this.isLocked = false;
        this.hasGroups = false;
        
        // HÃ¼crelerdeki kilitli gÃ¶rÃ¼nÃ¼mÃ¼ kaldÄ±r
        document.querySelectorAll('.karno-cell').forEach(cell => {
            cell.classList.remove('locked');
            cell.style.cursor = 'pointer';
        });
        
        console.log('ğŸ”“ Karno haritasÄ± kilidi aÃ§Ä±ldÄ± - yeni minterm giriÅŸi yapÄ±labilir');
    }
    
    showLockMessage() {
        // GeÃ§ici uyarÄ± mesajÄ± gÃ¶ster
        const message = document.createElement('div');
        message.className = 'lock-message';
        message.innerHTML = `
            <i class="fas fa-lock"></i>
            Gruplar oluÅŸturulduktan sonra minterm giriÅŸi yapÄ±lamaz!<br>
            <small>Yeni minterm girmek iÃ§in Ã¶nce "Temizle" butonuna basÄ±n.</small>
        `;
        
        document.body.appendChild(message);
        
        // 3 saniye sonra mesajÄ± kaldÄ±r
        setTimeout(() => {
            if (message && message.parentNode) {
                message.parentNode.removeChild(message);
            }
        }, 3000);
        
        console.log('âš ï¸ Kilitleme uyarÄ±sÄ± gÃ¶sterildi');
    }
    
    // Grup tÄ±klama ile vurgulama
    highlightGroupOnClick(groupId) {
        // Ã–nce tÃ¼m vurgulamalarÄ± temizle
        document.querySelectorAll('.karno-cell').forEach(cell => {
            cell.classList.remove('group-clicked');
            for (let i = 1; i <= 6; i++) {
                cell.classList.remove(`group-${i}-clicked`);
            }
        });
        
        // SeÃ§ili grubu vurgula
        const group = this.groups.find(g => g.id === groupId);
        if (group) {
            group.minterms.forEach(minterm => {
                const cell = document.querySelector(`[data-minterm="${minterm}"]`);
                if (cell) {
                    cell.classList.add('group-clicked', `group-${groupId}-clicked`);
                }
            });
            
            console.log(`ğŸ¯ Grup ${groupId} vurgulandÄ±:`, group.minterms);
        }
    }

    // ...existing code...
}

// Sayfa yÃ¼klendiÄŸinde uygulamayÄ± baÅŸlat
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM yÃ¼klendi, KarnoMap baÅŸlatÄ±lÄ±yor...');
    
    // EÄŸer zaten baÅŸlatÄ±lmÄ±ÅŸsa tekrar baÅŸlatma
    if (karnoApp) {
        console.log('KarnoMap zaten baÅŸlatÄ±lmÄ±ÅŸ, tekrar baÅŸlatÄ±lmÄ±yor');
        return;
    }
    
    try {
        karnoApp = new KarnoMap();
        console.log('KarnoMap baÅŸarÄ±yla baÅŸlatÄ±ldÄ±:', karnoApp);
    } catch (error) {
        console.error('KarnoMap baÅŸlatÄ±lÄ±rken hata oluÅŸtu:', error);
    }
});

// Global window.onload fallback
window.onload = function() {
    if (!karnoApp) {
        console.log('Fallback: window.onload ile KarnoMap baÅŸlatÄ±lÄ±yor...');
        try {
            karnoApp = new KarnoMap();
            console.log('KarnoMap fallback ile baÅŸlatÄ±ldÄ±:', karnoApp);
        } catch (error) {
            console.error('KarnoMap fallback baÅŸlatÄ±lÄ±rken hata oluÅŸtu:', error);
        }
    }
};
